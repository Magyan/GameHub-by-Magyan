<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jeu 5 - Flappy Ultime</title>
<style>
body{background:#0f1724;color:white;font-family:Arial;text-align:center;user-select:none;}
canvas{
    background:#111;
    margin-top:20px;
    border-radius:6px;
    border: 2px solid #ff8c00; 
    cursor: pointer;
}
button{padding:10px 20px;margin:10px;border-radius:8px;border:0;cursor:pointer;font-weight:bold;}
#start{background:#00ff66;} #back{background:#ff8c00;}
#message{color:white;font-weight:bold;margin-top:10px;}
#instructions {
    max-width: 600px;
    margin: 10px auto;
    padding: 15px;
    background: #0d141e;
    border-radius: 8px;
    text-align: left;
    font-size: 14px;
    color: #9aa0a6;
}
#instructions strong { color: white; }
</style>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="supabase_config.js"></script>
<script src="online_functions.js"></script>
</head>
<body>

<h1>Jeu 5 ‚Äî Flappy Ultime</h1>

<button id="start">D√©marrer</button>
<button id="back" onclick="location.href='index.html'">Retour</button>

<div id="instructions">
    <h3>Mode d'emploi :</h3>
    <ul>
        <li><strong>Objectif :</strong> Guider l'oiseau √† travers les espaces entre les tuyaux verts.</li>
        <li><strong>Contr√¥les :</strong> Cliquez/touchez l'√©cran ou appuyez sur <strong>ESPACE</strong> pour sauter. Appuyez sur <strong>P</strong> pour Pause.</li>
        <li><strong>Perdu :</strong> La partie se termine si vous touchez un tuyau, le sol ou le plafond.</li>
        <li><strong>Difficult√© :</strong> La vitesse augmente et l'√©cart entre les tuyaux diminue progressivement.</li>
    </ul>
</div>

<canvas id="game" width="400" height="500"></canvas>

<h2>Score : <span id="score">0</span></h2>
<div id="message">Cliquez sur D√©marrer ou sur l'√©cran pour commencer.</div>

<script>
const c = document.getElementById("game");
const ctx = c.getContext("2d");
const scoreDisplay = document.getElementById("score");
const messageDisplay = document.getElementById("message");

// --- Constantes du jeu (Initiales) ---
const BIRD_SIZE = 20;
const PIPE_WIDTH = 60;
const INITIAL_PIPE_GAP = 110; 
const PIPE_DISTANCE = 200; 
const INITIAL_PIPE_SPEED = 3;
const GRAVITY = 0.4;
const JUMP_VELOCITY = -7;
const GROUND_HEIGHT = 50; 
const PIPE_SPEED_MAX = 6;
const PIPE_GAP_MIN = 80;

// Dimensions
const CANVAS_HEIGHT = c.height;
const CANVAS_WIDTH = c.width;

// --- Variables de jeu ---
let bird, pipes, velocity, score, loop;
let gameStarted = false;
let isGameOver = false;
let isPaused = false; 
let currentPipeSpeed; 
let currentPipeGap;   

// --- Listeners ---
document.getElementById("start").onclick = start;
c.addEventListener("mousedown", jump); 
c.addEventListener("touchstart", jump); 
document.addEventListener("keydown", handleKeyInput);

function handleKeyInput(e) {
    if (e.key === ' ' || e.key === 'Space') {
        e.preventDefault();
        jump();
    } else if (e.key === 'p' || e.key === 'P') {
        togglePause();
    }
}

function togglePause() {
    if (!gameStarted || isGameOver) return;
    
    isPaused = !isPaused;
    if (isPaused) {
        if (loop) clearInterval(loop);
        messageDisplay.innerText = "Jeu en pause (Appuyez sur P)";
    } else {
        loop = setInterval(update, 1000 / 60);
        messageDisplay.innerText = "Jeu en cours...";
    }
}

function jump(e) {
    if (e) e.preventDefault(); 
    if (isGameOver || isPaused) return;

    if (!gameStarted) {
        start();
        return;
    }
    
    velocity = JUMP_VELOCITY;
}

function start() {
    if (loop) clearInterval(loop); 
    
    // Initialisation
    bird = { x: 50, y: CANVAS_HEIGHT / 2, rotation: 0 }; 
    velocity = 0;
    pipes = [];
    score = 0;
    isGameOver = false;
    isPaused = false;
    gameStarted = true;
    
    // Initialisation de la difficult√©
    currentPipeSpeed = INITIAL_PIPE_SPEED;
    currentPipeGap = INITIAL_PIPE_GAP;

    scoreDisplay.innerText = 0;
    messageDisplay.innerText = "Jeu en cours...";
    
    addPipe();
    
    loop = setInterval(update, 1000 / 60); 
}

function addPipe() {
    const minTop = 50;
    const maxTop = CANVAS_HEIGHT - GROUND_HEIGHT - currentPipeGap - 20; 
    const topPipeHeight = Math.random() * (maxTop - minTop) + minTop;

    pipes.push({
        x: CANVAS_WIDTH,
        top: topPipeHeight,
        bottom: topPipeHeight + currentPipeGap, 
        passed: false
    });
}

function update() {
    if (isPaused || isGameOver) return;
    
    // 1. Mouvement de l'oiseau
    velocity += GRAVITY;
    bird.y += velocity;

    // Calcul de la rotation
    bird.rotation = Math.min(Math.PI / 2, Math.max(-Math.PI / 4, velocity * 0.05));

    // 2. Mouvement et g√©n√©ration des tuyaux
    if (pipes.length === 0 || pipes[pipes.length - 1].x < CANVAS_WIDTH - PIPE_DISTANCE) {
        addPipe();
    }

    pipes.forEach((p, index) => {
        p.x -= currentPipeSpeed; 

        // 3. Scoring et Augmentation de la Difficult√©
        if (!p.passed && p.x + PIPE_WIDTH < bird.x) {
            score++;
            p.passed = true;
            
            if (score > 0 && score % 3 === 0) { 
                currentPipeSpeed = Math.min(PIPE_SPEED_MAX, currentPipeSpeed + 0.1); 
                currentPipeGap = Math.max(PIPE_GAP_MIN, currentPipeGap - 2); 
            }
        }

        // 4. Collision avec les tuyaux
        const collisionX = bird.x + BIRD_SIZE > p.x && bird.x < p.x + PIPE_WIDTH;
        const collisionY = bird.y < p.top || bird.y + BIRD_SIZE > p.bottom;

        if (collisionX && collisionY) {
            return gameOver();
        }

        // Nettoyage des tuyaux hors √©cran
        if (p.x + PIPE_WIDTH < 0) {
            pipes.splice(index, 1);
        }
    });

    // 5. Collision sol/plafond
    if (bird.y + BIRD_SIZE > CANVAS_HEIGHT - GROUND_HEIGHT || bird.y < 0) {
        return gameOver();
    }

    draw();
    scoreDisplay.innerText = score;
}

// --- Dessin Am√©lior√© ---
function draw() {
    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Dessiner le sol
    ctx.fillStyle = "#228B22"; 
    ctx.fillRect(0, CANVAS_HEIGHT - GROUND_HEIGHT, CANVAS_WIDTH, GROUND_HEIGHT);
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, CANVAS_HEIGHT - GROUND_HEIGHT, CANVAS_WIDTH, 2); 

    // Dessiner les tuyaux
    ctx.fillStyle = "#2E8B57"; 
    pipes.forEach(p => {
        ctx.fillRect(p.x, 0, PIPE_WIDTH, p.top);
        ctx.fillRect(p.x, p.bottom, PIPE_WIDTH, CANVAS_HEIGHT - GROUND_HEIGHT - p.bottom);
        
        ctx.strokeStyle = "#4CAF50";
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x, 0, PIPE_WIDTH, p.top);
        ctx.strokeRect(p.x, p.bottom, PIPE_WIDTH, CANVAS_HEIGHT - GROUND_HEIGHT - p.bottom);
    });

    // Dessiner l'oiseau (avec rotation)
    drawBird();
}

function drawBird() {
    ctx.save();
    
    const centerX = bird.x + BIRD_SIZE / 2;
    const centerY = bird.y + BIRD_SIZE / 2;
    
    ctx.translate(centerX, centerY);
    ctx.rotate(bird.rotation);
    
    ctx.fillStyle = "yellow";
    ctx.fillRect(-BIRD_SIZE / 2, -BIRD_SIZE / 2, BIRD_SIZE, BIRD_SIZE);
    
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(BIRD_SIZE / 4, -BIRD_SIZE / 4, BIRD_SIZE / 8, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

function gameOver() {
    if (isGameOver) return; 
    isGameOver = true;
    gameStarted = false;
    isPaused = true; 
    
    if (loop) clearInterval(loop);
    
    // Animation de la chute finale
    loop = setInterval(drawGameOver, 1000 / 60);

    messageDisplay.innerText = "GAME OVER! Score final : " + score;

    // Sauvegarde d√©clench√©e apr√®s l'alerte
    setTimeout(() => {
        // üì¢ SAUVEGARDE EN LIGNE
        saveScore(score, "Jeu 5 ‚Äî Flappy");
        alert(`Partie termin√©e ! Score : ${score}`);
    }, 500); 
}

function drawGameOver() {
    if (bird.y + BIRD_SIZE >= CANVAS_HEIGHT - GROUND_HEIGHT) {
        clearInterval(loop);
        loop = null;
        return;
    }
    
    velocity += GRAVITY;
    bird.y += velocity;
    bird.rotation = Math.min(Math.PI / 2, bird.rotation + 0.1); 
    
    draw();
}
</script>
</body>
</html>
