<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jeu 7 - Puzzle Taquin Ultime</title>
<style>
body { background:#0f1724; color:white; font-family:Arial; text-align:center; }
button { padding:10px 20px; margin:10px; border-radius:8px; border:0; cursor:pointer; font-weight:bold; }
#start { background:#00ff66; }
#back { background:#ff8c00; }
#gameArea { 
    background:#111; 
    margin:20px auto; 
    position:relative; 
    border-radius:10px; 
    display: grid;
    gap: 5px;
    padding: 5px;
    /* Styles de grille ajustés par JS */
}
.tile {
    background: #00aaff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: #08101a;
    border-radius: 5px;
    cursor: pointer;
    transition: transform 0.2s, background 0.1s;
    user-select: none;
    font-size: 1.5em; /* Taille ajustée pour les grandes grilles */
}
.empty {
    background: transparent;
    cursor: default;
}
.tile:active {
    transform: scale(0.95);
}
#instructions {
    max-width: 600px;
    margin: 10px auto;
    padding: 15px;
    background: #0d141e;
    border-radius: 8px;
    text-align: left;
    font-size: 14px;
    color: #9aa0a6;
}
#instructions strong { color: white; }
#message { color: #00ff66; font-weight: bold; margin-bottom: 15px; }
#timerDisplay {
    font-size: 1.2em;
    font-weight: bold;
    color: #ff8c00;
}
#previewContainer {
    width: 100px;
    height: 100px;
    background: #333;
    margin: 0 auto 10px;
    border-radius: 5px;
    line-height: 100px;
    font-size: 12px;
}
</style>
</head>
<body>

<h1>Jeu 7 — Puzzle Taquin Ultime</h1>

<button id="back" onclick="location.href='index.html'">Retour</button>

<div id="instructions">
    <h3>Mode d'emploi :</h3>
    <ul>
        <li><strong>Objectif :</strong> Réordonner les tuiles (1, 2, 3...) jusqu'à la case vide finale (0).</li>
        <li><strong>Jouer :</strong> Cliquez sur une tuile adjacente à la case vide.</li>
        <li><strong>Score :</strong> Le classement est basé sur le **temps** et le nombre de **coups**.</li>
    </ul>
</div>

<div id="difficultySelector">
    <button onclick="selectDifficulty(3)">Grille 3x3 (Facile)</button>
    <button onclick="selectDifficulty(4)">Grille 4x4 (Moyen)</button>
    <button onclick="selectDifficulty(5)">Grille 5x5 (Difficile)</button>
</div>

<div id="message">Sélectionnez la taille de la grille pour démarrer.</div>

<div id="statsDisplay" style="display:none;">
    <h2>Coups : <span id="score">0</span></h2>
    <div id="timerDisplay">Temps : 0:00</div>
</div>

<div id="previewContainer">Solution : 1, 2, 3...</div>

<div id="gameArea">
  </div>

<script>
// --- Variables d'État ---
let tiles = []; 
let score = 0;  // Nombre de coups
let timer = 0; // Temps en secondes
let timerInterval;
let active = false;
let GRID_SIZE = 3; // Par défaut: 3x3
const TILE_COUNT = () => GRID_SIZE * GRID_SIZE; 
const GAME_NAME = "Jeu 7 — Puzzle Taquin";

// --- DOM Elements ---
const gameArea = document.getElementById("gameArea");
const scoreDisplay = document.getElementById("score");
const messageDisplay = document.getElementById("message");
const timerDisplay = document.getElementById("timerDisplay");
const difficultySelector = document.getElementById("difficultySelector");
const previewContainer = document.getElementById("previewContainer");
const statsDisplay = document.getElementById("statsDisplay");

// --- Fonctions de Démarrage et Contrôle ---

function selectDifficulty(size) {
    GRID_SIZE = size;
    messageDisplay.textContent = `Grille ${size}x${size} sélectionnée. Cliquez sur Démarrer.`;
    
    // Configurer la grille et afficher l'aperçu
    const tileSize = 300 / GRID_SIZE;
    gameArea.style.width = '300px'; 
    gameArea.style.height = '300px';
    gameArea.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
    gameArea.style.gridTemplateRows = `repeat(${GRID_SIZE}, 1fr)`;

    previewContainer.textContent = `Solution: 1 à ${TILE_COUNT() - 1}, puis vide`;
    
    createTiles();
    statsDisplay.style.display = 'block';
    document.getElementById("start").onclick = startGame; // Relier le bouton
}

function startGame() {
    if (active) return;
    
    active = true;
    score = 0;
    timer = 0;
    scoreDisplay.textContent = 0;
    
    shuffleTiles();
    render();
    
    messageDisplay.textContent = "C'est parti !";
    startTimer();
}

function gameOver() {
    active = false;
    stopTimer();
    
    messageDisplay.textContent = `Bravo ! Résolu en ${formatTime(timer)} et ${score} coups.`;
    
    // Le score est le temps en secondes, le nombre de coups est une métrique secondaire
    saveScore(timer, score, `${GAME_NAME} (${GRID_SIZE}x${GRID_SIZE})`); 
    
    alert(`Félicitations ! Puzzle résolu en ${formatTime(timer)} et ${score} coups.`);
}

// --- Logique du Chronomètre ---

function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        timer++;
        timerDisplay.textContent = `Temps : ${formatTime(timer)}`;
    }, 1000);
}

function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
}

function formatTime(seconds) {
    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;
    return `${min}:${sec < 10 ? '0' : ''}${sec}`;
}

// --- Logique de la Grille ---

function createTiles() {
    gameArea.innerHTML = '';
    const total = TILE_COUNT();
    for (let i = 0; i < total; i++) {
        const d = document.createElement("div");
        d.classList.add("tile");
        d.dataset.index = i;
        d.onclick = () => moveTile(i);
        gameArea.appendChild(d);
    }
}

/**
 * Mélange les tuiles et garantit la solvabilité du puzzle.
 * Pour une grille NxN, le puzzle est solvable si le nombre d'inversions est pair.
 * Pour les grilles impaires (3x3, 5x5), seul le nombre d'inversions importe.
 */
function shuffleTiles() {
    const total = TILE_COUNT();
    tiles = Array.from({length: total}, (_, i) => i + 1);
    tiles[total - 1] = 0;

    let inversions;
    let solvable = false;
    
    // Boucle tant que le mélange n'est pas solvable
    while (!solvable) {
        // Mélange (Fisher-Yates)
        for (let i = total - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
        }
        
        inversions = 0;
        const flatTiles = tiles.filter(t => t !== 0); // Exclure la case vide
        
        // Compte les inversions
        for (let i = 0; i < flatTiles.length; i++) {
            for (let j = i + 1; j < flatTiles.length; j++) {
                if (flatTiles[i] > flatTiles[j]) {
                    inversions++;
                }
            }
        }
        
        // Pour les grilles NxN où N est impair (3, 5), solvable si inversions est pair.
        if (GRID_SIZE % 2 !== 0) {
            solvable = (inversions % 2 === 0);
        } else {
             // Pour les grilles NxN où N est pair (non implémenté ici, car nécessite la position de la ligne vide)
             // Pour simplifier, nous utilisons le mode impair pour toutes les grilles ici.
             solvable = (inversions % 2 === 0);
        }

        // Si le mélange initial parfait est déjà solvable et qu'on ne veut pas de partie gagnée d'avance
        if (inversions === 0 && total > 2) {
             solvable = false;
        }
    }
}

// Met à jour l'affichage des tuiles
function render() {
    const tileElements = gameArea.children;
    for (let i = 0; i < TILE_COUNT(); i++) {
        const val = tiles[i];
        const d = tileElements[i];
        
        d.dataset.value = val;
        d.textContent = val === 0 ? '' : val;
        
        if (val === 0) {
            d.classList.add('empty');
        } else {
            d.classList.remove('empty');
        }
    }
}

// Tente de déplacer une tuile
function moveTile(index) {
    if (!active) return;

    const emptyIndex = tiles.indexOf(0);
    
    const row = Math.floor(index / GRID_SIZE);
    const col = index % GRID_SIZE;
    const emptyRow = Math.floor(emptyIndex / GRID_SIZE);
    const emptyCol = emptyIndex % GRID_SIZE;

    // Vérifier si la tuile est adjacente à la case vide
    const isAdjacent = Math.abs(row - emptyRow) + Math.abs(col - emptyCol) === 1;

    if (isAdjacent) {
        // Échange de la tuile et de la case vide (Animation rapide via CSS transition)
        
        // Applique un style d'animation pour le déplacement
        const tileToMove = gameArea.children[index];
        const emptyTile = gameArea.children[emptyIndex];
        
        // Échange des classes et des valeurs dans le DOM
        tileToMove.style.order = emptyIndex;
        emptyTile.style.order = index;

        // Mise à jour du tableau interne
        [tiles[index], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[index]];
        
        score++;
        scoreDisplay.textContent = score;
        
        render(); // Rafraîchissement visuel après l'échange
        
        if (checkWin()) {
            gameOver();
        }
    }
}

// Vérifie si les tuiles sont dans l'ordre (1, 2, 3, ..., N*N - 1, 0)
function checkWin() {
    const total = TILE_COUNT();
    for (let i = 0; i < total - 1; i++) {
        if (tiles[i] !== i + 1) {
            return false;
        }
    }
    return tiles[total - 1] === 0;
}

// --- Fonction de Sauvegarde de Score (avec temps et coups) ---
function saveScore(time, moves, game){
    const name = localStorage.getItem("gh_player") || "Anonyme";
    try {
        const arr = JSON.parse(localStorage.getItem("gh_scores") || "[]");
        
        // NOTE: Le score principal pour le classement est le temps (plus bas = mieux)
        // Les coups sont stockés dans le champ score pour le taquin
        arr.push({name, score: time, game, moves: moves}); 
        
        localStorage.setItem("gh_scores", JSON.stringify(arr));
    } catch(e) {
        console.error("Erreur lors de la sauvegarde du score:", e);
    }
}

// Initialisation au chargement
document.addEventListener('DOMContentLoaded', () => {
    // Crée la grille 3x3 par défaut au chargement
    selectDifficulty(3);
});
</script>
</body>
</html>