<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jeu 4 - Snake Ultime</title>
<style>
body{background:#0f1724;color:white;font-family:Arial;text-align:center;user-select:none;}
canvas{
    background:#111;
    margin-top:20px;
    border-radius:6px;
    border: 2px solid #333;
}
button{padding:10px 20px;border-radius:8px;margin:10px;border:0;font-weight:bold;cursor:pointer;}
#start{background:#00ff66;} #back{background:#ff8c00;}
#instructions {
    max-width: 600px;
    margin: 10px auto;
    padding: 15px;
    background: #0d141e;
    border-radius: 8px;
    text-align: left;
    font-size: 14px;
    color: #9aa0a6;
}
#instructions strong { color: white; }
#statsDisplay {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-top: 15px;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="supabase_config.js"></script>
<script src="online_functions.js"></script>
</head>
<body>

<h1>Jeu 4 ‚Äî Snake Ultime</h1>

<button id="start">D√©marrer</button>
<button id="back" onclick="location.href='index.html'">Retour</button>

<div id="instructions">
    <h3>Mode d'emploi :</h3>
    <ul>
        <li><strong>Objectif :</strong> Mangez les cibles (Rouge = 1 pt, Or = 5 pts).</li>
        <li><strong>Contr√¥les :</strong> Touches <strong>Fl√®che</strong> ou **balayez (swipe)** sur l'√©cran.</li>
        <li><strong>Perdu :</strong> Touchez les bords, le corps du serpent ou les **Murs Temporaires** (bleus).</li>
        <li><strong>Difficult√© :</strong> Le serpent **acc√©l√®re** apr√®s chaque point !</li>
    </ul>
</div>

<div id="statsDisplay">
    <h2>Score : <span id="score">0</span></h2>
    <h2>Vitesse : <span id="speedDisplay">X</span> ms/case</h2>
</div>

<canvas id="game" width="400" height="400"></canvas>

<script>
// --- Constantes du Jeu ---
const GRID_SIZE = 20; 
const TILE_SIZE = 400 / GRID_SIZE;
const INITIAL_SPEED = 120; // D√©lai initial (ms)
const MIN_SPEED = 50; // D√©lai minimum (ms)
const SPEED_DECREASE_PER_POINT = 3; // ms de r√©duction
const WALL_CYCLE_TIME = 15; // secondes

// --- Variables de Jeu ---
let snake, dir, food, bonusFood, score, loop;
let nextDir;
let currentSpeed;
let walls = [];
let gameTimeSeconds = 0;
let active = false; // Indicateur d'√©tat du jeu

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const speedDisplay = document.getElementById("speedDisplay");

document.getElementById("start").onclick = start;

// --- Contr√¥les du joueur (Clavier/Swipe) ---
let touchStartX, touchStartY;

document.addEventListener("keydown", handleKeyInput);
canvas.addEventListener('touchstart', handleTouchStart, false);
canvas.addEventListener('touchmove', handleTouchMove, false);

function handleKeyInput(e) {
    if (!active && e.key.startsWith("Arrow")) {
        start(); 
    }
    if (!active) return;

    if (e.key === "ArrowUp" && dir !== "down") nextDir = "up";
    if (e.key === "ArrowDown" && dir !== "up") nextDir = "down";
    if (e.key === "ArrowLeft" && dir !== "right") nextDir = "left";
    if (e.key === "ArrowRight" && dir !== "left") nextDir = "right";
}

function handleTouchStart(e) {
    e.preventDefault();
    if (!active) {
        start(); 
        return;
    }
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}

function handleTouchMove(e) {
    if (!touchStartX || !active) return;
    
    const touchEndX = e.touches[0].clientX;
    const touchEndY = e.touches[0].clientY;
    
    const diffX = touchEndX - touchStartX;
    const diffY = touchEndY - touchStartY;

    if (Math.abs(diffX) > Math.abs(diffY)) {
        if (diffX > 0 && dir !== "left") nextDir = "right";
        else if (diffX < 0 && dir !== "right") nextDir = "left";
    } else {
        if (diffY > 0 && dir !== "up") nextDir = "down";
        else if (diffY < 0 && dir !== "down") nextDir = "up";
    }
    
    touchStartX = null;
    touchStartY = null;
}


// --- D√©marrage du Jeu ---
function start(){
    if (loop) clearInterval(loop);
    
    active = true;
    snake = [{x: Math.floor(GRID_SIZE / 4), y: Math.floor(GRID_SIZE / 2)}]; 
    dir = "right";
    nextDir = "right";
    score = 0;
    currentSpeed = INITIAL_SPEED;
    gameTimeSeconds = 0;
    walls = [];
    
    food = rand();
    bonusFood = null; 
    
    document.getElementById("score").innerText = 0;
    speedDisplay.innerText = currentSpeed;
    
    loop = setInterval(gameCycle, currentSpeed);
}

// Lancement du cycle de jeu (update et timer)
function gameCycle() {
    if (!active) {
        clearInterval(loop);
        return;
    }
    update();
    gameTimeSeconds++;
    
    if (currentSpeed !== loop._delay) {
        clearInterval(loop);
        loop = setInterval(gameCycle, currentSpeed);
        speedDisplay.innerText = currentSpeed;
    }
}

// --- Position Al√©atoire de la Nourriture ---
function rand(isBonus = false){
    let newFood;
    let maxTries = 100;
    let i = 0;
    
    do {
        newFood = {
            x: Math.floor(Math.random() * GRID_SIZE), 
            y: Math.floor(Math.random() * GRID_SIZE),
            type: isBonus ? 'bonus' : 'normal'
        };
        i++;
    } while (snake.some(s => s.x === newFood.x && s.y === newFood.y) || 
             walls.some(w => w.x === newFood.x && w.y === newFood.y) || i > maxTries);
    
    if (i >= maxTries) return null;
    return newFood;
}

// --- Logique de Mise √† Jour (Boucle de Jeu) ---
function update(){
    dir = nextDir; 

    const head = {...snake[0]};

    if(dir==="up") head.y--;
    if(dir==="down") head.y++;
    if(dir==="left") head.x--;
    if(dir==="right") head.x++;

    // 1. D√©tection de collision
    if(head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE || hitSelf(head) || hitWall(head)) {
        return gameOver();
    }

    snake.unshift(head);

    let ateFood = false;
    let pointsGained = 0;

    // 2. Gestion de la Nourriture Normale (Rouge)
    if(food && head.x === food.x && head.y === food.y){
        pointsGained += 1;
        food = rand();
        ateFood = true;
    } 
    
    // 3. Gestion de la Nourriture Bonus (Or)
    if(bonusFood && head.x === bonusFood.x && head.y === bonusFood.y){
        pointsGained += 5; 
        bonusFood = null; 
        ateFood = true;
    } 
    
    if (ateFood) {
        score += pointsGained;
        document.getElementById("score").innerText = score;
        
        if (currentSpeed > MIN_SPEED) { 
             currentSpeed = Math.max(MIN_SPEED, currentSpeed - (SPEED_DECREASE_PER_POINT * pointsGained));
             loop._delay = currentSpeed; 
        }
        
        if (!bonusFood && Math.random() < 0.20) {
            bonusFood = rand(true);
        }

    } else {
        snake.pop();
    }

    // 4. Gestion des Murs Temporaires
    updateWalls();
    
    draw();
}

// --- Gestion des Murs Temporaires (NOUVEAU) ---
function updateWalls() {
    const framesPerSecond = 1000 / currentSpeed;
    const framesPerCycle = WALL_CYCLE_TIME * framesPerSecond;
    
    if (gameTimeSeconds % framesPerCycle === 0) {
        
        if ((gameTimeSeconds / framesPerCycle) % 2 !== 0) {
            walls = [];
        } else {
             const corridorY = Math.floor(GRID_SIZE / 3) + Math.floor(Math.random() * (GRID_SIZE / 3));
             
             walls = [];
             for(let x = 3; x < GRID_SIZE - 3; x++) {
                 if (x < 8 || x > 11) {
                     walls.push({x: x, y: corridorY, active: true});
                 }
             }
        }
    }
}

// --- Dessin sur le Canvas ---
function draw(){
    ctx.fillStyle = "#111";
    ctx.fillRect(0,0,400,400);

    // 1. Dessin des Murs Temporaires (Bleus)
    ctx.fillStyle = "#4682b4"; 
    walls.filter(w => w.active).forEach(w => {
        ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    });

    // 2. Dessin du Serpent
    ctx.fillStyle = "lime";
    snake.forEach((s, index) => {
        ctx.fillStyle = index === 0 ? "#00ff66" : "lime"; 
        ctx.fillRect(s.x * TILE_SIZE, s.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#0f1724';
        ctx.strokeRect(s.x * TILE_SIZE, s.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    });

    // 3. Dessin de la Nourriture Normale (Rouge)
    if (food) {
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(food.x * TILE_SIZE + TILE_SIZE/2, food.y * TILE_SIZE + TILE_SIZE/2, TILE_SIZE/2 - 2, 0, Math.PI*2);
        ctx.fill();
    }

    // 4. Dessin de la Nourriture Bonus (Or/Jaune)
    if (bonusFood) {
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.arc(bonusFood.x * TILE_SIZE + TILE_SIZE/2, bonusFood.y * TILE_SIZE + TILE_SIZE/2, TILE_SIZE/2 - 2, 0, Math.PI*2);
        ctx.fill();
    }
}

// --- D√©tection de collision ---
function hitSelf(head){
    return snake.some((s,i) => i > 0 && s.x === head.x && s.y === head.y);
}

function hitWall(head){
    return walls.some(w => w.active && w.x === head.x && w.y === head.y);
}

// --- Fin de Jeu ---
function gameOver(){
    active = false;
    clearInterval(loop);
    
    // üì¢ SAUVEGARDE EN LIGNE
    saveScore(score, "Jeu 4 ‚Äî Snake");
    
    alert("GAME OVER ! Score final : " + score);
}
</script>
</body>
</html>
